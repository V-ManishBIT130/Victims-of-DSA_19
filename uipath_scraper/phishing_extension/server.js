// API Server for Phishing Detector Chrome Extension
// This server reads phishing_results.json from ML predictions and serves it to the extension

const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = 3000;

// Path to the phishing_results.json file generated by ML model
const PHISHING_RESULTS_PATH = path.join(__dirname, '..', 'phishing_results.json');
const EMAILS_DATA_PATH = path.join(__dirname, '..', 'emails_data.json');

// Enable CORS for Chrome extension
app.use(cors());
app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    message: 'Phishing Detector API Server is running',
    timestamp: new Date().toISOString()
  });
});

// Main API endpoint - Returns flagged phishing emails with predictions
app.get('/api/emails', (req, res) => {
  try {
    // Check if phishing_results.json exists (priority file with ML predictions)
    if (!fs.existsSync(PHISHING_RESULTS_PATH)) {
      // Fallback to emails_data.json if phishing_results doesn't exist
      if (!fs.existsSync(EMAILS_DATA_PATH)) {
        return res.status(404).json({
          success: false,
          error: 'No data files found',
          message: 'Neither phishing_results.json nor emails_data.json found. Run the ML model first.',
          timestamp: new Date().toISOString()
        });
      }
      
      // Use basic email data without predictions
      return handleBasicEmailData(res);
    }

    // Read the phishing_results.json file
    let rawData = fs.readFileSync(PHISHING_RESULTS_PATH, 'utf-8');
    
    // Remove UTF-8 BOM if present
    if (rawData.charCodeAt(0) === 0xFEFF) {
      rawData = rawData.substr(1);
    }
    
    // Trim whitespace
    rawData = rawData.trim();
    const resultsData = JSON.parse(rawData);

    // New format: results array contains all data
    const results = resultsData.results || [];
    const batchSummary = resultsData.batch_summary || {};

    // Map results to unified email format for extension
    const allEmails = results.map(result => ({
      email_id: result.email_id,
      sender: result.sender,
      sender_domain: result.sender_domain,
      subject: result.subject,
      date_received: result.date_received,
      prediction: result.prediction,
      is_phishing: result.prediction?.is_phishing || false,
      confidence: result.prediction?.confidence || 0,
      confidence_percentage: result.prediction?.confidence_percentage || 0,
      threat_level: result.prediction?.threat_level || 'UNKNOWN',
      risk_score: result.prediction?.risk_score || 0,
      verdict: result.prediction?.verdict || 'UNKNOWN',
      url_analysis: result.url_analysis,
      content_analysis: result.content_analysis,
      security_indicators: result.security_indicators,
      recommendations: result.recommendations,
      isPredicted: result.isPredicted || 0
    }));

    // Return ALL emails (both phishing and safe) so extension can show green/red dots
    const analyzedEmails = allEmails.filter(email => email.isPredicted === 1);

    // Get file stats for last modified time
    const stats = fs.statSync(PHISHING_RESULTS_PATH);
    const lastModified = stats.mtime;

    // Count phishing emails for logging
    const phishingCount = analyzedEmails.filter(e => e.is_phishing).length;
    const safeCount = analyzedEmails.filter(e => !e.is_phishing).length;

    // Return response with ALL analyzed emails
    res.json({
      success: true,
      count: analyzedEmails.length,
      phishing_count: phishingCount,
      safe_count: safeCount,
      total_emails: allEmails.length,
      emails: analyzedEmails, // All analyzed emails (phishing + safe)
      timestamp: new Date().toISOString(),
      file_last_modified: lastModified.toISOString()
    });

    console.log(`âœ… [${new Date().toLocaleTimeString()}] Served ${analyzedEmails.length} emails (ğŸ”´ ${phishingCount} phishing, ğŸŸ¢ ${safeCount} safe)`);

  } catch (error) {
    console.error('âŒ Error reading phishing data:', error.message);
    
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Failed to read or parse phishing results',
      timestamp: new Date().toISOString()
    });
  }
});

// Helper function for basic email data (no predictions)
function handleBasicEmailData(res) {
  try {
    let rawData = fs.readFileSync(EMAILS_DATA_PATH, 'utf-8');
    
    if (rawData.charCodeAt(0) === 0xFEFF) {
      rawData = rawData.substr(1);
    }
    
    rawData = rawData.trim();
    const allEmails = JSON.parse(rawData);

    // Filter emails with URLs (basic flagging)
    const flaggedEmails = allEmails.filter(email => email.has_urls === true && email.url_count > 0);

    const stats = fs.statSync(EMAILS_DATA_PATH);
    const lastModified = stats.mtime;

    res.json({
      success: true,
      count: flaggedEmails.length,
      total_emails: allEmails.length,
      emails: flaggedEmails,
      timestamp: new Date().toISOString(),
      file_last_modified: lastModified.toISOString(),
      note: 'Using basic email data - run ML model for predictions'
    });

    console.log(`âš ï¸ [${new Date().toLocaleTimeString()}] Served ${flaggedEmails.length} flagged emails (basic mode, no predictions)`);

  } catch (error) {
    throw error;
  }
}

// Get all emails (including non-flagged)
app.get('/api/emails/all', (req, res) => {
  try {
    if (!fs.existsSync(EMAILS_DATA_PATH)) {
      return res.status(404).json({
        success: false,
        error: 'emails_data.json not found',
        timestamp: new Date().toISOString()
      });
    }

    const rawData = fs.readFileSync(EMAILS_DATA_PATH, 'utf-8');
    const allEmails = JSON.parse(rawData);

    res.json({
      success: true,
      count: allEmails.length,
      emails: allEmails,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Get statistics
app.get('/api/stats', (req, res) => {
  try {
    if (!fs.existsSync(EMAILS_DATA_PATH)) {
      return res.status(404).json({
        success: false,
        error: 'emails_data.json not found',
        timestamp: new Date().toISOString()
      });
    }

    const rawData = fs.readFileSync(EMAILS_DATA_PATH, 'utf-8');
    const allEmails = JSON.parse(rawData);

    const flaggedEmails = allEmails.filter(email => email.has_urls === true);
    const totalUrls = allEmails.reduce((sum, email) => sum + (email.url_count || 0), 0);
    const stats = fs.statSync(EMAILS_DATA_PATH);

    res.json({
      success: true,
      statistics: {
        total_emails: allEmails.length,
        flagged_emails: flaggedEmails.length,
        safe_emails: allEmails.length - flaggedEmails.length,
        total_urls_found: totalUrls,
        file_last_modified: stats.mtime.toISOString(),
        file_size_bytes: stats.size
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Start server
app.listen(PORT, () => {
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ›¡ï¸  PHISHING DETECTOR API SERVER');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`âœ… Server running on http://localhost:${PORT}`);
  console.log(`ğŸ“‚ Priority file: ${PHISHING_RESULTS_PATH}`);
  console.log(`ğŸ“‚ Fallback file: ${EMAILS_DATA_PATH}`);
  console.log('');
  console.log('ğŸ“¡ Available Endpoints:');
  console.log(`   GET  http://localhost:${PORT}/health`);
  console.log(`   GET  http://localhost:${PORT}/api/emails        (flagged emails only)`);
  console.log(`   GET  http://localhost:${PORT}/api/emails/all    (all emails)`);
  console.log(`   GET  http://localhost:${PORT}/api/stats         (statistics)`);
  console.log('');
  console.log('ğŸ”„ Ready to serve data to Chrome Extension');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  // Check files
  if (fs.existsSync(PHISHING_RESULTS_PATH)) {
    const stats = fs.statSync(PHISHING_RESULTS_PATH);
    console.log(`âœ… phishing_results.json found (${stats.size} bytes, modified: ${stats.mtime.toLocaleString()})`);
  } else {
    console.log('âš ï¸  phishing_results.json not found - will use emails_data.json');
  }
  
  if (fs.existsSync(EMAILS_DATA_PATH)) {
    const stats = fs.statSync(EMAILS_DATA_PATH);
    console.log(`âœ… emails_data.json found (${stats.size} bytes, modified: ${stats.mtime.toLocaleString()})`);
  } else {
    console.log('âš ï¸  WARNING: emails_data.json not found!');
    console.log('   Make sure UiPath workflow is running and generating the file.');
  }
  console.log('');
});

// Prevent accidental shutdown - only exit on explicit command
let shutdownRequested = false;

process.on('SIGINT', () => {
  if (shutdownRequested) {
    console.log('\n\nğŸ›‘ Shutting down API server...');
    process.exit(0);
  } else {
    shutdownRequested = true;
    console.log('\nâš ï¸  Press Ctrl+C again within 3 seconds to shutdown...');
    setTimeout(() => {
      shutdownRequested = false;
      console.log('âœ… Shutdown cancelled - server still running');
    }, 3000);
  }
});

// Keep the process alive
setInterval(() => {
  // Heartbeat every 30 seconds
}, 30000);
